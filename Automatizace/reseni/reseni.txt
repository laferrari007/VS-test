# AI Generované řešení úkolů pro předmět: Automatizace
# Vytvořeno pomocí Groq API
# Datum: 2025-09-15 22:00:35
# POZOR: Řešení odpovídají konkrétním úkolům ze zadání!

Řešení 1: Designujte jednoduchý RoboRIO a vytvořte diagram bloků pro kontrolu motorů, která umožňuje měnit rychlost motorů pomocí analogového vstupu.

**Popis problému:**
Cílem tohoto úkolu je navrhnout jednoduchý RoboRIO a vytvořit diagram bloků pro kontrolu motorů, který umožňuje měnit rychlost motorů pomocí analogového vstupu. RoboRIO je mikrokontrolér, který může být používán jako centrální jednotka pro řízení robotů.

**Design RoboRIO:**
Pro tento úkol použijeme mikrokontrolér Arduino. RoboRIO bude mít následující součástky:

* Mikrokontrolér Arduino (například Arduino Uno)
* Motorový driver (například L293D)
* Analogový vstup (například potenciometr)
* Motor (například DC motor)

**Diagram bloků:**

1. Získání analogového vstupu z potenciometru pomocí funkce `analogRead()`.
2. Přepojení analogového vstupu do funkce `map()` pro převod hodnoty z analogového vstupu na hodnotu mezi 0 a 255 (dle potřeby).
3. Použití funkce `analogWrite()` pro odeslání hodnoty do motorového driveru.
4. Použití funkce `motorForward()` pro řízení motoru v dopředném směru.
5. Použití funkce `motorBackward()` pro řízení motoru v zádřevném směru.

**Kód:**
```c++
const int potentiometerPin = A0;  // Pin pro analogový vstup
const int motorPin = 9;  // Pin pro motorový driver
const int maxSpeed = 255;  // Maximální rychlost motoru

void setup() {
  pinMode(potentiometerPin, INPUT);
  pinMode(motorPin, OUTPUT);
}

void loop() {
  int analogValue = analogRead(potentiometerPin);
  int speed = map(analogValue, 0, 1023, 0, maxSpeed);
  analogWrite(motorPin, speed);
}
```

**Testování:**
Pro testování RoboRIO použijeme potenciometr, který bude měřit hodnotu v závislosti na poloze potenciometru. Rychlost motoru bude záviset na hodnotě potenciometru.

**Řešení 2: Zkuste napsat jednoduchý algoritmus pro řízení pohybu robotu pomocí PID regulace. Použijte simulaci nebo reálný robot na potvrzení funkčnosti.**

**Popis problému:**
Cílem tohoto úkolu je napsat jednoduchý algoritmus pro řízení pohybu robotu pomocí PID regulace. PID regulace je metoda, která umožňuje řídit pohyb robotu na základě chyb mezi skutečným a požadovaným stavem.

**Algoritmus PID:**

1. Stanovení požadovaného stavu (například poloha na mapě).
2. Získání skutečného stavu (například položení senzorů na robotu).
3. Vypočtení chyb mezi skutečným a požadovaným stavem.
4. Vypočtení regulátore PID (P, I, D) na základě chyb.
5. Odeslání hodnoty regulátora PID do motorového driveru pro řízení motoru.

**Kód:**
```c++
const int desiredPosition = 100;  // Požadovaný stav
const int currentPosition = 50;  // Skutečný stav
const int kp = 2;  // Regulátor P
const int ki = 1;  // Regulátor I
const int kd = 0.5;  // Regulátor D
const int maxSpeed = 255;  // Maximální rychlost motoru

int error = desiredPosition - currentPosition;
int pidOutput = kp * error + ki * error * time + kd * (error - previousError);
analogWrite(motorPin, pidOutput);
```

**Testování:**
Pro testování algoritmu PID použijeme simulaci nebo reálný robot. Robot bude pohybovat směrem k požadovanému stavu, a algoritmus PID bude upravovat rychlost motoru na základě chyb mezi skutečným a požadovaným stavem.

**Řešení 3: Implementujte a testujte algoritmus pro detekci hran pomocí kamerového senzoru v prostředí simulace. Použijte knihovny pro zpracování obrazu (OpenCV).**

**Popis problému:**
Cílem tohoto úkolu je implementovat a testovat algoritmus pro detekci hran pomocí kamerového senzoru v prostředí simulace. Algoritmus bude používat knihovny pro zpracování obrazu (OpenCV).

**Algoritmus detekce hran:**

1. Získání obrazu z kamerového senzoru.
2. Převod obrazu na černobílý.
3. Vypočtení gradientu obrazu.
4. Vypočtení hran v obraze.
5. Odeslání hodnoty hran do motorového driveru pro řízení motoru.

**Kód:**
```c++
#include <opencv2/opencv.hpp>

cv::Mat image;  // Obraz
cv::Mat gray;  // Černobílý obraz
cv::Mat grad;  // Gradient obrazu
cv::Mat edges;  // Hran v obraze

void detectEdges() {
  cv::cvtColor(image, gray, cv::COLOR_BGR2GRAY);
  cv::Laplacian(gray, grad, cv::DEPTH_DEFAULT, 1);
  cv::Canny(grad, edges, 50, 150);
}

int main() {
  // Získání obrazu z kamerového senzoru
  cv::Mat image = cv::imread("image.jpg");

  detectEdges();

  // Vypočtení hran v obraze
  int edgesValue = cv::sum(edges)[0];

  // Odeslání hodnoty hran do motorového driveru
  analogWrite(motorPin, edgesValue);
}
```

**Testování:**
Pro testování algoritmu detekce hran použijeme simulaci nebo reálný robot. Robot bude pohybovat směrem ke hranám v obraze, a algoritmus detekce hran bude upravovat rychlost motoru na základě hodnoty hran.

**Řešení 4: Navrhněte a implementujte systémy pro automatické měření teploty a vlhkosti v laboratoři. Použijte senzory a mikrokontroléry (například Arduino).**

**Popis problému:**
Cílem tohoto úkolu je navrhnout a implementovat systémy pro automatické měření teploty a vlhkosti v laboratoři. Systém bude používat senzory a mikrokontroléry (například
